console.log(`Background script loaded`);var e=`Ov23liAQQQpfH1gP98nn`,t=`8b0c9ca15cb272a8e6ddbfd8e286c50b6c2f9218`;async function n(){let n=chrome.identity.getRedirectURL(),r=`https://github.com/login/oauth/authorize?client_id=${e}&scope=repo&redirect_uri=${encodeURIComponent(n)}`;chrome.identity.launchWebAuthFlow({url:r,interactive:!0},async r=>{if(chrome.runtime.lastError||!r){console.error(`Auth failed:`,chrome.runtime.lastError);return}let i=new URL(r).searchParams.get(`code`);if(!i){console.error(`No code received`);return}try{let r=await(await fetch(`https://github.com/login/oauth/access_token`,{method:`POST`,headers:{"Content-Type":`application/json`,Accept:`application/json`},body:JSON.stringify({client_id:e,client_secret:t,code:i,redirect_uri:n})})).json();if(r.error){console.error(`Token exchange error:`,r.error_description);return}let a=r.access_token;if(!a){console.error(`No token received`);return}let o=await(await fetch(`https://api.github.com/user`,{headers:{Authorization:`Bearer ${a}`}})).json();await chrome.storage.sync.set({ghToken:a,ghUsername:o.login,ghEmail:o.email||`${o.login}@users.noreply.github.com`}),console.log(`GitHub authentication successful!`)}catch(e){console.error(`Auth error:`,e)}})}async function r(e,t){let n={Authorization:`token ${e}`,Accept:`application/vnd.github+json`,"Content-Type":`application/json`},[r,i]=t.split(`/`);try{let e=await fetch(`https://api.github.com/repos/${t}`,{headers:n});if(e.ok){console.log(`Repository ${t} exists.`);return}if(e.status!==404)throw Error(`Unexpected error checking repo: ${e.status}`);let r=await fetch(`https://api.github.com/user/repos`,{method:`POST`,headers:n,body:JSON.stringify({name:i,description:`Automated backup of Codeforces solutions`,private:!1,auto_init:!0})});if(!r.ok){let e=await r.json().catch(()=>({}));throw Error(e.message||`Failed to create repo: ${r.status}`)}console.log(`Created repository ${t}`)}catch(e){throw console.error(`Repo creation error:`,e),e}}async function i(e,t,n,i,a,o){let s=`${n}/${i}/`,c={Authorization:`token ${e}`,Accept:`application/vnd.github+json`,"Content-Type":`application/json`};await r(e,t);let l=await fetch(`https://api.github.com/repos/${t}/branches/main`,{headers:c});if(!l.ok){let e=await l.json().catch(()=>({}));throw Error(e.message||`Failed to get branch: ${l.status}`)}let u=await l.json(),d=u.commit.sha,f=u.commit.commit.tree.sha,p=a.map(e=>({path:`${s}${e.fileName}`,mode:`100644`,type:`blob`,content:e.content})),m=await fetch(`https://api.github.com/repos/${t}/git/trees`,{method:`POST`,headers:c,body:JSON.stringify({base_tree:f,tree:p})});if(!m.ok){let e=await m.json().catch(()=>({}));throw Error(e.message||`Failed to create tree: ${m.status}`)}let h=(await m.json()).sha,g=await fetch(`https://api.github.com/repos/${t}/git/commits`,{method:`POST`,headers:c,body:JSON.stringify({message:o,parents:[d],tree:h})});if(!g.ok){let e=await g.json().catch(()=>({}));throw Error(e.message||`Failed to create commit: ${g.status}`)}let _=(await g.json()).sha,v=await fetch(`https://api.github.com/repos/${t}/git/refs/heads/main`,{method:`PATCH`,headers:c,body:JSON.stringify({sha:_})});if(!v.ok){let e=await v.json().catch(()=>({}));throw Error(e.message||`Failed to update ref: ${v.status}`)}return console.log(`Successfully committed files to ${s} in ${t}`),await v.json()}chrome.runtime.onMessage.addListener((e,t,r)=>{if(e.action===`startAuth`)return n(),r({success:!0}),!0;if(e.action===`PUSH_TO_GITHUB`){let{token:n,repo:r,contestId:a,problemNo:o,files:s,message:c}=e.data;return i(n,r,a,o,s,c).then(()=>{chrome.tabs.sendMessage(t.tab.id,{action:`GITHUB_PUSH_SUCCESS`,problemName:e.data.problemName})}).catch(e=>{chrome.tabs.sendMessage(t.tab.id,{action:`GITHUB_PUSH_FAILED`,error:e.message})}),!0}return!1});var a={};chrome.webRequest.onBeforeRequest.addListener(e=>{if(e.method===`POST`&&e.requestBody?.formData){let t=e.requestBody.formData,n=t.sourceCode?.[0]||t.source?.[0];n&&(a[e.requestId]={code:n,problemId:t.submittedProblemIndex?.[0]})}},{urls:[`*://codeforces.com/problemset/submit*`,`*://codeforces.com/contest/*/submit*`]},[`requestBody`]),chrome.webRequest.onHeadersReceived.addListener(e=>{let t=e.requestId;a[t]&&(e.statusCode>=300&&e.statusCode<400&&o(e.tabId,a[t]),delete a[t])},{urls:[`*://codeforces.com/problemset/submit*`,`*://codeforces.com/contest/*/submit*`]});async function o(e,t){let{codeforcesUsername:n,githubRepo:r}=await chrome.storage.sync.get([`codeforcesUsername`,`githubRepo`]),i=n||`Hacker_bot`;chrome.tabs.sendMessage(e,{action:`UPDATE_STATUS`,msg:`Waiting for verdict...`});let a=setInterval(async()=>{try{let n=await(await fetch(`https://codeforces.com/api/user.status?handle=${i}&from=1&count=1`)).json();if(n.status!==`OK`||n.result.length===0)return;let r=n.result[0];if(r.verdict===`TESTING`)return;if(clearInterval(a),r.verdict===`OK`){let n=`https://codeforces.com/contest/${r.contestId}/problem/${r.problem.index}`,i=await(await fetch(n)).text(),a=await chrome.storage.sync.get([`ghToken`,`githubRepo`,`ghUsername`]);chrome.tabs.sendMessage(e,{action:`SYNC_READY`,code:t.code,problemHtml:i,problemName:r.problem.name,contestId:r.contestId,problemNo:r.problem.index,language:r.programmingLanguage,syncData:a})}else chrome.tabs.sendMessage(e,{action:`SYNC_FAILED`,reason:r.verdict})}catch{clearInterval(a),chrome.tabs.sendMessage(e,{action:`SYNC_FAILED`,reason:`Network error`})}},3e3)}