console.log(`Background script loaded`);async function e(){console.log(`[AUTH] Starting Secure GitHub authentication...`);let e=``;try{e=(await(await fetch(`http://localhost:3000/api/config`)).json()).clientId}catch(e){console.error(`[AUTH] Could not fetch config from server:`,e);return}let t=chrome.identity.getRedirectURL(),n=`https://github.com/login/oauth/authorize?client_id=${e}&scope=repo&redirect_uri=${encodeURIComponent(t)}`;console.log(`[AUTH] Launching auth flow...`),chrome.identity.launchWebAuthFlow({url:n,interactive:!0},async e=>{if(chrome.runtime.lastError||!e){console.error(`[AUTH] Auth failed:`,chrome.runtime.lastError?.message);return}let t=new URL(e).searchParams.get(`code`);if(!t){console.error(`[AUTH] No code found`);return}try{console.log(`[AUTH] Sending code to backend for secure exchange...`);let e=await(await fetch(`http://localhost:3000/api/exchange`,{method:`POST`,headers:{"Content-Type":`application/json`},body:JSON.stringify({code:t})})).json();if(e.error||!e.access_token){console.error(`[AUTH] Backend token exchange failed:`,e.error);return}let n=e.access_token;console.log(`[AUTH] Token received from backend!`);let r=await(await fetch(`https://api.github.com/user`,{headers:{Authorization:`token ${n}`}})).json();await chrome.storage.sync.set({ghToken:n,ghUsername:r.login,ghEmail:r.email||`${r.login}@users.noreply.github.com`}),chrome.runtime.sendMessage({action:`AUTH_FINISHED`,success:!0}),console.log(`Successfully authenticated as ${r.login}`)}catch(e){console.error(`[AUTH] Error during backend communication:`,e)}})}async function t(e,t){console.log(`[REPO] Checking if repo exists: ${t}`);let n={Authorization:`token ${e}`,Accept:`application/vnd.github+json`,"Content-Type":`application/json`},[r,i]=t.split(`/`);try{let e=await fetch(`https://api.github.com/repos/${t}`,{headers:n});if(e.ok){console.log(`[REPO] Repository ${t} already exists.`);return}if(e.status!==404)throw Error(`Unexpected status ${e.status} when checking repo`);console.log(`[REPO] Repo not found. Creating new repo: ${i}`);let r=await fetch(`https://api.github.com/user/repos`,{method:`POST`,headers:n,body:JSON.stringify({name:i,description:`Automated backup of Codeforces solutions`,private:!1,auto_init:!0})});if(!r.ok){let e=await r.json().catch(()=>({}));throw console.error(`[REPO] Failed to create repo:`,e),Error(e.message||`Failed to create repo: ${r.status}`)}console.log(`[REPO] Successfully created repository ${t}`)}catch(e){throw console.error(`[REPO] Error in createRepoIfNotExists:`,e),e}}async function n(e,n,r,i,a,o,s){console.log(`[PUSH] Starting push to ${n}`),console.log(`[PUSH] Contest: ${r}, Problem: ${i}`),console.log(`[PUSH] Files:`,a.map(e=>e.fileName).join(`, `)),console.log(`[PUSH] Commit message: ${o}`);let c=`${r}/${i} - ${s}/`;console.log(`[PUSH] Target folder path: ${c}`);let l={Authorization:`token ${e}`,Accept:`application/vnd.github+json`,"Content-Type":`application/json`};await t(e,n),console.log(`[PUSH] Fetching main branch info...`);let u=await fetch(`https://api.github.com/repos/${n}/branches/main`,{headers:l});if(!u.ok){let e=await u.json().catch(()=>({}));throw console.error(`[PUSH] Failed to get branch:`,e),Error(e.message||`Failed to get branch: ${u.status}`)}let d=await u.json(),f=d.commit.sha,p=d.commit.commit.tree.sha;console.log(`[PUSH] Current head SHA:`,f.substring(0,7)),console.log(`[PUSH] Base tree SHA:`,p.substring(0,7));let m=a.map(e=>({path:`${c}${e.fileName}`,mode:`100644`,type:`blob`,content:e.content}));console.log(`[PUSH] Tree entries prepared:`,m.map(e=>e.path)),console.log(`[PUSH] Creating new Git tree...`);let h=await fetch(`https://api.github.com/repos/${n}/git/trees`,{method:`POST`,headers:l,body:JSON.stringify({base_tree:p,tree:m})});if(!h.ok){let e=await h.json().catch(()=>({}));throw console.error(`[PUSH] Tree creation failed:`,e),Error(e.message||`Failed to create tree: ${h.status}`)}let g=await h.json();console.log(`[PUSH] New tree SHA:`,g.sha.substring(0,7)),console.log(`[PUSH] Creating new commit...`);let _=await fetch(`https://api.github.com/repos/${n}/git/commits`,{method:`POST`,headers:l,body:JSON.stringify({message:o,parents:[f],tree:g.sha})});if(!_.ok){let e=await _.json().catch(()=>({}));throw console.error(`[PUSH] Commit creation failed:`,e),Error(e.message||`Failed to create commit: ${_.status}`)}let v=await _.json();console.log(`[PUSH] New commit SHA:`,v.sha.substring(0,7)),console.log(`[PUSH] Updating main branch reference...`);let y=await fetch(`https://api.github.com/repos/${n}/git/refs/heads/main`,{method:`PATCH`,headers:l,body:JSON.stringify({sha:v.sha})});if(!y.ok){let e=await y.json().catch(()=>({}));throw console.error(`[PUSH] Failed to update ref:`,e),Error(e.message||`Failed to update ref: ${y.status}`)}return console.log(`[PUSH] Successfully committed files to ${c} in ${n}`),await y.json()}chrome.runtime.onMessage.addListener((t,r,i)=>{if(console.log(`[MESSAGE] Received message:`,t.action),t.action===`startAuth`)return console.log(`[MESSAGE] Starting auth flow...`),e(),i({success:!0}),!0;if(t.action===`PUSH_TO_GITHUB`){console.log(`[MESSAGE] PUSH_TO_GITHUB request received`);let{token:e,repo:i,contestId:a,problemNo:o,files:s,message:c,problemName:l}=t.data;return console.log(`[MESSAGE] Push data:`,{repo:i,contestId:a,problemNo:o,fileCount:s.length}),n(e,i,a,o,s,c,l).then(()=>{console.log(`[PUSH] Push completed successfully`),chrome.tabs.sendMessage(r.tab.id,{action:`GITHUB_PUSH_SUCCESS`,problemName:t.data.problemName})}).catch(e=>{console.error(`[PUSH] Push failed:`,e.message),chrome.tabs.sendMessage(r.tab.id,{action:`GITHUB_PUSH_FAILED`,error:e.message})}),!0}return!1}),console.log(`CFPusher background service worker loaded`);var r=new Map;chrome.webRequest.onBeforeRequest.addListener(e=>{if(e.method!==`POST`||!e.requestBody?.formData)return;let t=e.requestBody.formData,n=t.sourceCode?.[0]||t.source?.[0];n&&(r.set(e.requestId,{code:n,problemId:t.submittedProblemIndex?.[0]||t.problemIndex?.[0]}),console.log(`Captured submission:`,e.requestId,`Problem ID:`,r.get(e.requestId).problemId))},{urls:[`*://codeforces.com/problemset/submit*`,`*://codeforces.com/contest/*/submit*`]},[`requestBody`]),chrome.webRequest.onHeadersReceived.addListener(e=>{let t=e.requestId,n=r.get(t);if(!n)return;let a=e.statusCode>=300&&e.statusCode<400;console.log(`Headers received:`,e.statusCode,a?`(redirect)`:``),a&&(console.log(`Redirect detected â†’ Starting verdict watchdog`),i(e.tabId,n)),r.delete(t)},{urls:[`*://codeforces.com/problemset/submit*`,`*://codeforces.com/contest/*/submit*`]},[`responseHeaders`]);async function i(e,t){let n=(await chrome.storage.sync.get([`codeforcesUsername`,`githubRepo`])).codeforcesUsername||`Hacker_bot`;chrome.tabs.sendMessage(e,{action:`UPDATE_STATUS`,msg:`Waiting for verdict...`});let r=setInterval(async()=>{try{let i=await(await fetch(`https://codeforces.com/api/user.status?handle=${n}&from=1&count=1`)).json();if(i.status!==`OK`||i.result.length===0)return;let a=i.result[0];if(a.verdict===`TESTING`)return;if(clearInterval(r),a.verdict===`OK`){console.log(a);let n=`https://codeforces.com/contest/${a.contestId}/problem/${a.problem.index}`,r=await(await fetch(n)).text();console.log(r);let i=await chrome.storage.sync.get([`ghToken`,`ghUsername`,`githubRepo`]);chrome.tabs.sendMessage(e,{action:`SYNC_READY`,code:t.code,problemHtml:r,problemName:a.problem.name,contestId:a.contestId,problemNo:a.problem.index,language:a.programmingLanguage,performance:{time:a.timeConsumedMillis,memory:a.memoryConsumedBytes,testCases:a.passedTestCount,submissionId:a.id,rating:a.problem.rating||`Unrated`},syncData:i})}}catch(t){console.error(`Watchdog error:`,t),clearInterval(r),chrome.tabs.sendMessage(e,{action:`SYNC_FAILED`,reason:`Network or API error`})}},3e3)}