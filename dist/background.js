console.log(`Background script loaded`);var e=`Ov23liAQQQpfH1gP98nn`,t=`8b0c9ca15cb272a8e6ddbfd8e286c50b6c2f9218`;async function n(){console.log(`[AUTH] Starting GitHub authentication...`);let n=chrome.identity.getRedirectURL();console.log(`[AUTH] Redirect URL:`,n);let r=`https://github.com/login/oauth/authorize?client_id=${e}&scope=repo&redirect_uri=${encodeURIComponent(n)}`;console.log(`[AUTH] Launching auth URL:`,r),chrome.identity.launchWebAuthFlow({url:r,interactive:!0},async r=>{if(chrome.runtime.lastError||!r){console.error(`[AUTH] Auth failed:`,chrome.runtime.lastError?.message||`No response URL`);return}console.log(`[AUTH] Received redirect URL:`,r);let i=new URL(r).searchParams.get(`code`);if(!i){console.error(`[AUTH] No authorization code found in redirect URL`);return}console.log(`[AUTH] Authorization code received:`,i.substring(0,10)+`...`);try{console.log(`[AUTH] Exchanging code for token...`);let r=await(await fetch(`https://github.com/login/oauth/access_token`,{method:`POST`,headers:{"Content-Type":`application/json`,Accept:`application/json`},body:JSON.stringify({client_id:e,client_secret:t,code:i,redirect_uri:n})})).json();if(console.log(`[AUTH] Token exchange response:`,r),r.error){console.error(`[AUTH] Token exchange error:`,r.error_description||r.error);return}let a=r.access_token;if(!a){console.error(`[AUTH] No access token received`);return}console.log(`[AUTH] Access token received (length):`,a.length),console.log(`[AUTH] Fetching GitHub user info...`);let o=await(await fetch(`https://api.github.com/user`,{headers:{Authorization:`Bearer ${a}`}})).json();console.log(`[AUTH] GitHub user:`,o.login,o.email||`(no email)`),await chrome.storage.sync.set({ghToken:a,ghUsername:o.login,ghEmail:o.email||`${o.login}@users.noreply.github.com`}),console.log(`GitHub authentication successful! Saved token and username.`)}catch(e){console.error(`[AUTH] Unexpected error during auth:`,e)}})}async function r(e,t){console.log(`[REPO] Checking if repo exists: ${t}`);let n={Authorization:`token ${e}`,Accept:`application/vnd.github+json`,"Content-Type":`application/json`},[r,i]=t.split(`/`);try{let e=await fetch(`https://api.github.com/repos/${t}`,{headers:n});if(e.ok){console.log(`[REPO] Repository ${t} already exists.`);return}if(e.status!==404)throw Error(`Unexpected status ${e.status} when checking repo`);console.log(`[REPO] Repo not found. Creating new repo: ${i}`);let r=await fetch(`https://api.github.com/user/repos`,{method:`POST`,headers:n,body:JSON.stringify({name:i,description:`Automated backup of Codeforces solutions`,private:!1,auto_init:!0})});if(!r.ok){let e=await r.json().catch(()=>({}));throw console.error(`[REPO] Failed to create repo:`,e),Error(e.message||`Failed to create repo: ${r.status}`)}console.log(`[REPO] Successfully created repository ${t}`)}catch(e){throw console.error(`[REPO] Error in createRepoIfNotExists:`,e),e}}async function i(e,t,n,i,a,o,s){console.log(`[PUSH] Starting push to ${t}`),console.log(`[PUSH] Contest: ${n}, Problem: ${i}`),console.log(`[PUSH] Files:`,a.map(e=>e.fileName).join(`, `)),console.log(`[PUSH] Commit message: ${o}`);let c=`${n}/${i} - ${s}/`;console.log(`[PUSH] Target folder path: ${c}`);let l={Authorization:`token ${e}`,Accept:`application/vnd.github+json`,"Content-Type":`application/json`};await r(e,t),console.log(`[PUSH] Fetching main branch info...`);let u=await fetch(`https://api.github.com/repos/${t}/branches/main`,{headers:l});if(!u.ok){let e=await u.json().catch(()=>({}));throw console.error(`[PUSH] Failed to get branch:`,e),Error(e.message||`Failed to get branch: ${u.status}`)}let d=await u.json(),f=d.commit.sha,p=d.commit.commit.tree.sha;console.log(`[PUSH] Current head SHA:`,f.substring(0,7)),console.log(`[PUSH] Base tree SHA:`,p.substring(0,7));let m=a.map(e=>({path:`${c}${e.fileName}`,mode:`100644`,type:`blob`,content:e.content}));console.log(`[PUSH] Tree entries prepared:`,m.map(e=>e.path)),console.log(`[PUSH] Creating new Git tree...`);let h=await fetch(`https://api.github.com/repos/${t}/git/trees`,{method:`POST`,headers:l,body:JSON.stringify({base_tree:p,tree:m})});if(!h.ok){let e=await h.json().catch(()=>({}));throw console.error(`[PUSH] Tree creation failed:`,e),Error(e.message||`Failed to create tree: ${h.status}`)}let g=await h.json();console.log(`[PUSH] New tree SHA:`,g.sha.substring(0,7)),console.log(`[PUSH] Creating new commit...`);let _=await fetch(`https://api.github.com/repos/${t}/git/commits`,{method:`POST`,headers:l,body:JSON.stringify({message:o,parents:[f],tree:g.sha})});if(!_.ok){let e=await _.json().catch(()=>({}));throw console.error(`[PUSH] Commit creation failed:`,e),Error(e.message||`Failed to create commit: ${_.status}`)}let v=await _.json();console.log(`[PUSH] New commit SHA:`,v.sha.substring(0,7)),console.log(`[PUSH] Updating main branch reference...`);let y=await fetch(`https://api.github.com/repos/${t}/git/refs/heads/main`,{method:`PATCH`,headers:l,body:JSON.stringify({sha:v.sha})});if(!y.ok){let e=await y.json().catch(()=>({}));throw console.error(`[PUSH] Failed to update ref:`,e),Error(e.message||`Failed to update ref: ${y.status}`)}return console.log(`[PUSH] Successfully committed files to ${c} in ${t}`),await y.json()}chrome.runtime.onMessage.addListener((e,t,r)=>{if(console.log(`[MESSAGE] Received message:`,e.action),e.action===`startAuth`)return console.log(`[MESSAGE] Starting auth flow...`),n(),r({success:!0}),!0;if(e.action===`PUSH_TO_GITHUB`){console.log(`[MESSAGE] PUSH_TO_GITHUB request received`);let{token:n,repo:r,contestId:a,problemNo:o,files:s,message:c,problemName:l}=e.data;return console.log(`[MESSAGE] Push data:`,{repo:r,contestId:a,problemNo:o,fileCount:s.length}),i(n,r,a,o,s,c,l).then(()=>{console.log(`[PUSH] Push completed successfully`),chrome.tabs.sendMessage(t.tab.id,{action:`GITHUB_PUSH_SUCCESS`,problemName:e.data.problemName})}).catch(e=>{console.error(`[PUSH] Push failed:`,e.message),chrome.tabs.sendMessage(t.tab.id,{action:`GITHUB_PUSH_FAILED`,error:e.message})}),!0}return!1}),console.log(`CFPusher background service worker loaded`);var a=new Map;chrome.webRequest.onBeforeRequest.addListener(e=>{if(e.method!==`POST`||!e.requestBody?.formData)return;let t=e.requestBody.formData,n=t.sourceCode?.[0]||t.source?.[0];n&&(a.set(e.requestId,{code:n,problemId:t.submittedProblemIndex?.[0]||t.problemIndex?.[0]}),console.log(`Captured submission:`,e.requestId,`Problem ID:`,a.get(e.requestId).problemId))},{urls:[`*://codeforces.com/problemset/submit*`,`*://codeforces.com/contest/*/submit*`]},[`requestBody`]),chrome.webRequest.onHeadersReceived.addListener(e=>{let t=e.requestId,n=a.get(t);if(!n)return;let r=e.statusCode>=300&&e.statusCode<400;console.log(`Headers received:`,e.statusCode,r?`(redirect)`:``),r&&(console.log(`Redirect detected â†’ Starting verdict watchdog`),o(e.tabId,n)),a.delete(t)},{urls:[`*://codeforces.com/problemset/submit*`,`*://codeforces.com/contest/*/submit*`]},[`responseHeaders`]);async function o(e,t){let n=(await chrome.storage.sync.get([`codeforcesUsername`,`githubRepo`])).codeforcesUsername||`Hacker_bot`;chrome.tabs.sendMessage(e,{action:`UPDATE_STATUS`,msg:`Waiting for verdict...`});let r=setInterval(async()=>{try{let i=await(await fetch(`https://codeforces.com/api/user.status?handle=${n}&from=1&count=1`)).json();if(i.status!==`OK`||i.result.length===0)return;let a=i.result[0];if(a.verdict===`TESTING`)return;if(clearInterval(r),a.verdict===`OK`){console.log(a);let n=`https://codeforces.com/contest/${a.contestId}/problem/${a.problem.index}`,r=await(await fetch(n)).text();console.log(r);let i=await chrome.storage.sync.get([`ghToken`,`ghUsername`,`githubRepo`]);chrome.tabs.sendMessage(e,{action:`SYNC_READY`,code:t.code,problemHtml:r,problemName:a.problem.name,contestId:a.contestId,problemNo:a.problem.index,language:a.programmingLanguage,performance:{time:a.timeConsumedMillis,memory:a.memoryConsumedBytes,testCases:a.passedTestCount,submissionId:a.id,rating:a.problem.rating||`Unrated`},syncData:i})}}catch(t){console.error(`Watchdog error:`,t),clearInterval(r),chrome.tabs.sendMessage(e,{action:`SYNC_FAILED`,reason:`Network or API error`})}},3e3)}